/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-ULID.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : ULID
 #	author : miyako
 #	2025/08/09
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-ULID.h"

#pragma mark -

static std::random_device rd;
static std::mt19937 generator(rd());

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- ULID
            
			case 1 :
                ULID_from_UUID(params);
				break;
            case 2 :
                ULID_to_UUID(params);
                break;
            case 3 :
                Generate_ULID(params);
                break;
            case 4 :
                ULID_Get_timestamp(params);
                break;
            case 5 :
                ULID_Set_timestamp(params);
                break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

typedef std::basic_string<PA_Unichar> CUTF16String;

static void fromUstr(CUTF16String& u16, std::string& u8) {
    
#ifdef _WIN32
    int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)u16.c_str(), u16.length(), NULL, 0, NULL, NULL);
    
    if(len){
        std::vector<uint8_t> buf(len + 1);
        if(WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)u16.c_str(), u16.length(), (LPSTR)&buf[0], len, NULL, NULL)){
            u8 = std::string((const char *)&buf[0]);
        }
    }else{
            u8 = std::string((const char *)"");
    }
#else
    CFStringRef str = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar *)u16.c_str(), u16.length());
    if(str){
        
        size_t size = CFStringGetMaximumSizeForEncoding(CFStringGetLength(str), kCFStringEncodingUTF8) + sizeof(uint8_t);
        std::vector<uint8_t> buf(size);
        CFIndex len = 0;
        CFStringGetBytes(str, CFRangeMake(0, CFStringGetLength(str)), kCFStringEncodingUTF8, 0, true, (UInt8 *)&buf[0], size, &len);

        u8 = std::string((const char *)&buf[0], len);
        CFRelease(str);
    }
#endif
}

static void toUstr(std::string& u8, CUTF16String& u16) {
    
#ifdef _WIN32
    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)u8.c_str(), u8.length(), NULL, 0);
    
    if(len){
        std::vector<uint8_t> buf((len + 1) * sizeof(PA_Unichar));
        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)u8.c_str(), u8.length(), (LPWSTR)&buf[0], len)){
            u16 = CUTF16String((const PA_Unichar *)&buf[0]);
        }
    }else{
        u16 = CUTF16String((const PA_Unichar *)L"");
    }
    
#else
    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, (const unsigned char *)u8.c_str(), u8.length(), kCFStringEncodingUTF8, true);
    if(str){
        CFIndex len = CFStringGetLength(str);
        std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
        CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
        u16 = CUTF16String((const PA_Unichar *)&buf[0]);
        CFRelease(str);
    }
#endif
}

static uint8_t hexCharToValue(char c) {
    
    if (c >= '0' && c <= '9') return c - '0';
    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
    
    return 0;
}

static std::string bytesToHex(const std::vector<uint8_t> &data) {
    static const char* hexDigits = "0123456789abcdef";
    std::string out(data.size() * 2, '0');
    for (size_t i = 0; i < data.size(); i++) {
        out[i*2]     = hexDigits[data[i] >> 4];
        out[i*2 + 1] = hexDigits[data[i] & 0x0F];
    }
    return out;
}

static std::array<uint8_t, 16> hexToBytes(const std::string &hex) {
 
    std::array<uint8_t, 16> bytes{};
    
    if (hex.size() == 32) {
        for (size_t i = 0; i < 16; i++) {
            uint8_t high = hexCharToValue(hex[2 * i]);
            uint8_t low  = hexCharToValue(hex[2 * i + 1]);
            bytes[i] = (high << 4) | low;
        }
    }
    
    return bytes;
}

static void ULID_from_UUID(PA_PluginParameters params) {

    PA_Unistring *ustr = PA_GetStringParameter(params, 1);
    CUTF16String returnValue;

    CUTF16String u16((const PA_Unichar *)ustr->fString, (PA_long32)ustr->fLength);
    std::string u8;
    fromUstr(u16 ,u8);
    
    std::array<uint8_t, 16> bytes = hexToBytes(u8);
    std::vector<uint8_t> vec(bytes.begin(), bytes.end());
    
    std::string str = ulid::Marshal(ulid::UnmarshalBinary(vec));
    toUstr(str, returnValue);
    
    PA_ReturnString(params, (PA_Unichar *)returnValue.c_str());
}

static void ULID_to_UUID(PA_PluginParameters params) {
    
    PA_Unistring *ustr = PA_GetStringParameter(params, 1);
    CUTF16String returnValue;

    CUTF16String u16((const PA_Unichar *)ustr->fString, (PA_long32)ustr->fLength);
    std::string u8;
    fromUstr(u16 ,u8);
    
    ulid::ULID ulid = ulid::Unmarshal(u8);
    
    std::vector<uint8_t> bytes = ulid::MarshalBinary(ulid);
    std::string str = bytesToHex(bytes);
    
    toUstr(str, returnValue);
    
    PA_ReturnString(params, (PA_Unichar *)returnValue.c_str());
}

static void Generate_ULID(PA_PluginParameters params) {

    CUTF16String returnValue;
    
    ulid::ULID ulid;
    ulid::EncodeTimeSystemClockNow(ulid);
    ulid::EncodeEntropyMt19937(generator, ulid);
    
    std::string str = ulid::Marshal(ulid);
    toUstr(str, returnValue);
    
    PA_ReturnString(params, (PA_Unichar *)returnValue.c_str());
}

static const char *CROCKFORD_ALPHABET = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";

static int decode_crockford_char(char c) {
    const char *p = strchr(CROCKFORD_ALPHABET, c);
    return p ? (int)(p - CROCKFORD_ALPHABET) : -1;
}

/*
static uint64_t ulid_decode_timestamp_ms(std::string& str) {
        
    if (str.length() < 10) return 0;
    
    uint64_t total = 0;
    
    // Each char = 5 bits; first 10 chars = 50 bits total
    for (int i = 0; i < 10; i++) {
        int val = decode_crockford_char(str.at(i));
        if (val < 0) return 0;
        total = (total << 5) | (uint64_t)val;

        std::cout << "Step " << i << ": char='" << str[i] << "' val=" << val
                         << " total=0x" << std::hex << total << std::dec << " (" << total << ")\n";
           
    }
    
    // Timestamp is the top 48 bits; discard the lowest 2 bits
    return total >> 2;
}
*/

static std::string ms_to_iso8601(uint64_t ms) {

    time_t t = (time_t)(ms / 1000);
    long msec = (long)(ms % 1000);

    struct tm tm_utc;

#if defined(_WIN32)
    gmtime_s(&tm_utc, &t);
#else
    gmtime_r(&t, &tm_utc);
#endif
    
    char tm_str[20];//19+1
    if(strftime(tm_str, sizeof(tm_str), "%Y-%m-%dT%H:%M:%S", &tm_utc) == 19){
        char iso_str[25];//24+1
        if(snprintf(iso_str, sizeof(iso_str), "%s.%03ldZ", tm_str, msec) == 24) {
            return std::string(iso_str, sizeof(iso_str));
        }
    }

    return "";
}

static uint64_t ms_to_iso8601_to_ms(const std::string& iso) {
    
    std::tm tm = {};
        int milliseconds = 0;
    
    std::istringstream ss(iso);
    ss >> std::get_time(&tm, "%Y-%m-%dT%H:%M:%S");
    
    if (!ss.fail()) {
        // Parse milliseconds if present
            if (ss.peek() == '.') {
                ss.get(); // consume '.'
                char ms_str[4] = {'0', '0', '0', '\0'};
                ss.read(ms_str, 3);
                milliseconds = std::stoi(ms_str);
            }
        
        // Assume 'Z' at end (UTC)
        // Convert tm to time_t (seconds since epoch)
#if defined(_WIN32) || defined(_WIN64)
        time_t time_sec = _mkgmtime(&tm);
#else
        time_t time_sec = timegm(&tm);
#endif

        if (time_sec != -1) {
            return static_cast<int64_t>(time_sec) * 1000 + milliseconds;
        }
    }
    
    return 0;
}

static void ULID_Get_timestamp(PA_PluginParameters params) {
    
    PA_Unistring *ustr = PA_GetStringParameter(params, 1);
    CUTF16String returnValue;

    CUTF16String u16((const PA_Unichar *)ustr->fString, (PA_long32)ustr->fLength);
    std::string u8;
    fromUstr(u16 ,u8);
    
    ulid::ULID ulid = ulid::Unmarshal(u8);
    time_t ms = ulid::Time(ulid);//not really time_t

    std::string str = ms_to_iso8601(ms);
    toUstr(str, returnValue);
    
    PA_ReturnString(params, (PA_Unichar *)returnValue.c_str());
}

static void ULID_Set_timestamp(PA_PluginParameters params) {
    
    PA_Unistring *ustr = PA_GetStringParameter(params, 2);
    CUTF16String returnValue;

    CUTF16String u16((const PA_Unichar *)ustr->fString, (PA_long32)ustr->fLength);
    std::string u8;
    fromUstr(u16 ,u8);
    
    time_t ms = ms_to_iso8601_to_ms(u8);

    ustr = PA_GetStringParameter(params, 1);
    u16 = CUTF16String((const PA_Unichar *)ustr->fString, (PA_long32)ustr->fLength);
    fromUstr(u16 ,u8);
    
    ulid::ULID ulid = ulid::Unmarshal(u8);
    ulid::EncodeTime(ms, ulid);
    
    std::string str = ulid::Marshal(ulid);
    toUstr(str, returnValue);
    
    PA_ReturnString(params, (PA_Unichar *)returnValue.c_str());
}
