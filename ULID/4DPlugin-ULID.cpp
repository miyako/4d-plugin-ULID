/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-ULID.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : ULID
 #	author : miyako
 #	2025/08/09
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-ULID.h"

#pragma mark -

static std::random_device rd;
static std::mt19937 generator(rd());

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- ULID
            
			case 1 :
                ULID_from_UUID(params);
				break;
            case 2 :
                ULID_to_UUID(params);
                break;
            case 3 :
                Generate_ULID(params);
                break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

typedef std::basic_string<PA_Unichar> CUTF16String;

static void fromUstr(CUTF16String& u16, std::string& u8) {
    
#ifdef _WIN32
    int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)u16.c_str(), u16.length(), NULL, 0, NULL, NULL);
    
    if(len){
        std::vector<uint8_t> buf(len + 1);
        if(WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)u16.c_str(), u16.length(), (LPSTR)&buf[0], len, NULL, NULL)){
            u8 = std::string((const char *)&buf[0]);
        }
    }else{
            u8 = std::string((const char *)"");
    }
#else
    CFStringRef str = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar *)u16.c_str(), u16.length());
    if(str){
        
        size_t size = CFStringGetMaximumSizeForEncoding(CFStringGetLength(str), kCFStringEncodingUTF8) + sizeof(uint8_t);
        std::vector<uint8_t> buf(size);
        CFIndex len = 0;
        CFStringGetBytes(str, CFRangeMake(0, CFStringGetLength(str)), kCFStringEncodingUTF8, 0, true, (UInt8 *)&buf[0], size, &len);

        u8 = std::string((const char *)&buf[0], len);
        CFRelease(str);
    }
#endif
}

static void toUstr(std::string& u8, CUTF16String& u16) {
    
#ifdef _WIN32
    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)u8.c_str(), u8.length(), NULL, 0);
    
    if(len){
        std::vector<uint8_t> buf((len + 1) * sizeof(PA_Unichar));
        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)u8.c_str(), u8.length(), (LPWSTR)&buf[0], len)){
            u16 = CUTF16String((const PA_Unichar *)&buf[0]);
        }
    }else{
        u16 = CUTF16String((const PA_Unichar *)L"");
    }
    
#else
    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, (const unsigned char *)u8.c_str(), u8.length(), kCFStringEncodingUTF8, true);
    if(str){
        CFIndex len = CFStringGetLength(str);
        std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
        CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
        u16 = CUTF16String((const PA_Unichar *)&buf[0]);
        CFRelease(str);
    }
#endif
}

static uint8_t hexCharToValue(char c) {
    
    if (c >= '0' && c <= '9') return c - '0';
    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
    
    return 0;
}

static std::string bytesToHex(const std::vector<uint8_t> &data) {
    static const char* hexDigits = "0123456789abcdef";
    std::string out(data.size() * 2, '0');
    for (size_t i = 0; i < data.size(); i++) {
        out[i*2]     = hexDigits[data[i] >> 4];
        out[i*2 + 1] = hexDigits[data[i] & 0x0F];
    }
    return out;
}

static std::array<uint8_t, 16> hexToBytes(const std::string &hex) {
 
    std::array<uint8_t, 16> bytes{};
    
    if (hex.size() == 32) {
        for (size_t i = 0; i < 16; i++) {
            uint8_t high = hexCharToValue(hex[2 * i]);
            uint8_t low  = hexCharToValue(hex[2 * i + 1]);
            bytes[i] = (high << 4) | low;
        }
    }
    
    return bytes;
}

static void ULID_from_UUID(PA_PluginParameters params) {

    PA_Unistring *ustr = PA_GetStringParameter(params, 1);
    CUTF16String returnValue;

    CUTF16String u16((const PA_Unichar *)ustr->fString, (PA_long32)ustr->fLength);
    std::string u8;
    fromUstr(u16 ,u8);
    
    std::array<uint8_t, 16> bytes = hexToBytes(u8);
    std::vector<uint8_t> vec(bytes.begin(), bytes.end());
    
    std::string str = ulid::Marshal(ulid::UnmarshalBinary(vec));
    toUstr(str, returnValue);
    
    PA_ReturnString(params, (PA_Unichar *)returnValue.c_str());
}

static void ULID_to_UUID(PA_PluginParameters params) {
    
    PA_Unistring *ustr = PA_GetStringParameter(params, 1);
    CUTF16String returnValue;

    CUTF16String u16((const PA_Unichar *)ustr->fString, (PA_long32)ustr->fLength);
    std::string u8;
    fromUstr(u16 ,u8);
    
    ulid::ULID ulid = ulid::Unmarshal(u8);
    
    std::vector<uint8_t> bytes = ulid::MarshalBinary(ulid);
    std::string str = bytesToHex(bytes);
    
    toUstr(str, returnValue);
    
    PA_ReturnString(params, (PA_Unichar *)returnValue.c_str());
}

static void Generate_ULID(PA_PluginParameters params) {

    CUTF16String returnValue;
    
    ulid::ULID ulid;
    ulid::EncodeTimeSystemClockNow(ulid);
    ulid::EncodeEntropyMt19937(generator, ulid);
    
    std::string str = ulid::Marshal(ulid);
    toUstr(str, returnValue);
    
    PA_ReturnString(params, (PA_Unichar *)returnValue.c_str());
}
